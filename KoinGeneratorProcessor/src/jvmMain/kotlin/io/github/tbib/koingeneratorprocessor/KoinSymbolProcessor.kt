package io.github.tbib.koingeneratorprocessor

import com.google.devtools.ksp.processing.*
import com.google.devtools.ksp.symbol.*
import com.google.devtools.ksp.validate
import com.squareup.kotlinpoet.*
import com.squareup.kotlinpoet.ksp.toClassName
import com.squareup.kotlinpoet.ksp.toTypeName
import com.squareup.kotlinpoet.ksp.writeTo
import io.github.tbib.koingeneratorannotations.*

class KoinSymbolProcessor(private val env: SymbolProcessorEnvironment) : SymbolProcessor {
    private val logger: KSPLogger = env.logger
    private val codeGenerator = env.codeGenerator

    override fun process(resolver: Resolver): List<KSAnnotated> {
        val packageNames = env.options["packageName"]?.split(',')?.map { it.trim() }?.filter { it.isNotBlank() }

        val allModuleSymbols = resolver.getSymbolsWithAnnotation(Module::class.qualifiedName!!)
            .filterIsInstance<KSClassDeclaration>()
            .filter { it.classKind == ClassKind.INTERFACE }

        val moduleInterfaces = if (packageNames.isNullOrEmpty()) {
            logger.logging("KoinGenerator: 'packageName' option not provided. Searching all packages for @Module.")
            allModuleSymbols
        } else {
            logger.logging("KoinGenerator: Searching for @Module in packages: ${packageNames.joinToString()}")
            allModuleSymbols.filter { module ->
                val modulePackage = module.packageName.asString()
                packageNames.any { providedPackage ->
                    modulePackage.startsWith(providedPackage)
                }
            }
        }

        val (valid, invalid) = moduleInterfaces.toList().partition { it.validate() }

        valid.forEach { generateModuleImplementation(it, resolver) }

        return invalid
    }

    private fun generateModuleImplementation(moduleInterface: KSClassDeclaration, resolver: Resolver) {
        val interfaceName = moduleInterface.toClassName()
        val generatedClassName = "Generated${interfaceName.simpleName}"
        val packageName = interfaceName.packageName

        val fileSpecBuilder = FileSpec.builder(packageName, generatedClassName)
            .addFileComment("Auto-generated by KoinGenerator. Do not edit.")
            .addImport("org.koin.core.module", "Module")
            .addImport("org.koin.dsl", "module")
            .addImport("org.koin.core.qualifier", "named")
            .addImport(interfaceName.packageName, interfaceName.simpleName)

        if (resolver.getSymbolsWithAnnotation(Bind::class.qualifiedName!!).any()) {
            fileSpecBuilder.addImport("org.koin.dsl", "bind")
        }

        val definitions = mutableListOf<CodeBlock>()

        collectDefinitions<Single>(resolver, definitions, "single")
        collectDefinitions<Factory>(resolver, definitions, "factory")
        
        val viewModelSymbols = resolver.getSymbolsWithAnnotation(KoinViewModel::class.qualifiedName!!).filter { it.validate() }
        val viewModelDeclarations = viewModelSymbols.filterIsInstance<KSClassDeclaration>().toList()

        if (viewModelDeclarations.isNotEmpty()) {
            fileSpecBuilder.addImport("org.koin.core.module.dsl", "viewModel")
            viewModelDeclarations.forEach {
                definitions.add(createDefinition(it, "viewModel"))
            }
        }

        collectScopedDefinitions(resolver, definitions)
        collectProvides(resolver, definitions)

        val moduleProperty = PropertySpec.builder("module", ClassName("org.koin.core.module", "Module"), KModifier.OVERRIDE)
            .initializer(
                CodeBlock.builder()
                    .addStatement("module {")
                    .indent()
                    .apply { definitions.forEach { addStatement("%L", it) } }
                    .unindent()
                    .addStatement("}")
                    .build()
            )
            .build()

        val generatedClass = TypeSpec.classBuilder(generatedClassName)
            .addModifiers(KModifier.INTERNAL)
            .addSuperinterface(interfaceName)
            .addProperty(moduleProperty)
            .build()

        val factoryFunction = FunSpec.builder(interfaceName.simpleName)
            .returns(interfaceName)
            .addStatement("return %T()", ClassName(packageName, generatedClassName))
            .build()

        fileSpecBuilder.addType(generatedClass)
        fileSpecBuilder.addFunction(factoryFunction)

        val sourceFiles = resolver.getAllFiles().toList().toTypedArray()
        fileSpecBuilder.build().writeTo(codeGenerator, Dependencies(true, *sourceFiles))
    }

    private inline fun <reified T : Annotation> collectDefinitions(
        resolver: Resolver,
        definitions: MutableList<CodeBlock>,
        koinDsl: String
    ) {
        resolver.getSymbolsWithAnnotation(T::class.qualifiedName!!)
            .filterIsInstance<KSClassDeclaration>()
            .filter { it.validate() }
            .forEach { classDeclaration ->
                val definition = createDefinition(classDeclaration, koinDsl)
                definitions.add(definition)
            }
    }

    private fun collectScopedDefinitions(
        resolver: Resolver,
        definitions: MutableList<CodeBlock>
    ) {
        val scopedSymbols = resolver.getSymbolsWithAnnotation(Scoped::class.qualifiedName!!)
            .filterIsInstance<KSClassDeclaration>()
            .filter { it.validate() }

        val scopes = mutableMapOf<String, MutableList<CodeBlock>>()

        scopedSymbols.forEach { classDeclaration ->
            val scopedAnnotation = classDeclaration.annotations.find { it.shortName.asString() == "Scoped" }!!
            val scopeName = scopedAnnotation.arguments.find { it.name?.asString() == "scopeName" }?.value as? String

            if (scopeName.isNullOrBlank()) {
                logger.warn("@Scoped used without a scopeName on ${classDeclaration.simpleName.asString()}. Skipping.")
                return@forEach
            }

            val definition = createDefinition(classDeclaration, "scoped")
            scopes.getOrPut(scopeName) { mutableListOf() }.add(definition)
        }

        scopes.forEach { (scopeName, scopeDefs) ->
            val scopeBlock = CodeBlock.builder()
                .addStatement("scope(named(%S)) {", scopeName)
                .indent()
                .apply { scopeDefs.forEach { addStatement("%L", it) } }
                .unindent()
                .addStatement("}")
                .build()
            definitions.add(scopeBlock)
        }
    }

    private fun collectProvides(
        resolver: Resolver,
        definitions: MutableList<CodeBlock>
    ) {
        resolver.getSymbolsWithAnnotation(Provides::class.qualifiedName!!)
            .filterIsInstance<KSFunctionDeclaration>()
            .filter { it.validate() }
            .forEach { func ->
                val definition = createProvidesDefinition(func)
                definitions.add(definition)
            }
    }

    private fun createDefinition(classDeclaration: KSClassDeclaration, koinDsl: String): CodeBlock {
        val className = classDeclaration.toClassName()

        val constructor = classDeclaration.primaryConstructor
        if (constructor == null) {
            logger.error("Cannot find primary constructor for ${classDeclaration.qualifiedName?.asString()}", classDeclaration)
            return CodeBlock.of("// Error: No primary constructor for %T", className)
        }
        val params = constructor.parameters.map { createGetStatement(it) }.joinToCode()

        val qualifier = classDeclaration.getQualifier()

        val providesStatement = CodeBlock.builder()
        val finalKoinDsl = if(koinDsl == "scoped") "scoped" else koinDsl

        if (!qualifier.isNullOrBlank()) {
            providesStatement.add("%L(named(%S)) { %T(%L) }", finalKoinDsl, qualifier, className, params)
        } else {
            providesStatement.add("%L { %T(%L) }", finalKoinDsl, className, params)
        }

        val bindAnnotation = classDeclaration.annotations.find { it.shortName.asString() == "Bind" }
        if (bindAnnotation != null) {
            val bindTypeArg = bindAnnotation.arguments.first().value
            if (bindTypeArg is KSType) {
                providesStatement.add(" bind %T::class", bindTypeArg.toTypeName())
            }
        }

        return providesStatement.build()
    }

    private fun createProvidesDefinition(func: KSFunctionDeclaration): CodeBlock {
        val functionName = func.simpleName.asString()
        val params = func.parameters.map { createGetStatement(it) }.joinToCode()
        val providesStatement = CodeBlock.builder()

        val parent = func.parentDeclaration
        if (parent is KSClassDeclaration && parent.classKind == ClassKind.OBJECT) {
            providesStatement.add("single { %T.%L(%L) }", parent.toClassName(), functionName, params)
        } else { // Top-level function
            val member = MemberName(func.packageName.asString(), functionName)
            providesStatement.add("single { %M(%L) }", member, params)
        }

        return providesStatement.build()
    }

    private fun createGetStatement(parameter: KSValueParameter): CodeBlock {
        // This function is designed to work across multiple modules.
        // It does NOT try to resolve the parameter's type at compile time.
        // Instead, it generates a `get()` call, and lets Koin resolve the
        // dependency at RUNTIME. This is the correct approach for multi-module DI.

        // Check for a @Named annotation to generate get(named("..."))
        val namedAnnotation = parameter.annotations.find { it.shortName.asString() == "Named" }
        if (namedAnnotation != null) {
            val namedValue = namedAnnotation.arguments.first().value as? String
            if (namedValue != null) {
                return CodeBlock.of("get(named(%S))", namedValue)
            }
        }
    
        // For ALL other parameters, regardless of their type or where they come from,
        // we generate a generic `get()`. 
        return CodeBlock.of("get()")
    }

    private fun KSAnnotated.getQualifier(): String? {
        val annotation = annotations.firstOrNull {
            it.shortName.asString() in listOf("Single", "Factory", "ViewModel", "Scoped", "KoinViewModel")
        }
        val qualifier = annotation?.arguments?.find { it.name?.asString() == "qualifier" }?.value as? String
        if(qualifier?.isNotBlank() == true) return qualifier

        val namedAnnotation = annotations.find { it.shortName.asString() == "Named" }
        return namedAnnotation?.arguments?.firstOrNull()?.value as? String
    }
}
